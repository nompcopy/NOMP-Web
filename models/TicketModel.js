// Ticket.js
var utils = require('../lib/utils');

var mongoose = require('mongoose');
extend = require('mongoose-schema-extend');
var Schema = mongoose.Schema;
var ObjectId = Schema.ObjectId;


// TicketModel schema
var TicketModelSchema = new Schema({
    name: {type: String, default: '', trim: true},
    classification: { type: Schema.ObjectId, ref: 'classification'},
    // TODO: auto generated by user type
    source_actor_type: {type: Schema.ObjectId, ref: 'actor_source_type'},
    target_actor_type: {type: Schema.ObjectId, ref: 'actor_target_type'},

    contact_phone: {type: String},
    contact_mobile: {type: String},
    contact_email: {type: String},

    quantity: {type: Number},
    description: {type: String},
    keywords: [{type: String}],

    creation_date: {type: Date, default: Date.now},
    end_date: {type: Date, default: addDate()},
    start_date: {type: Date, default: Date.now},
    expiration_date: {type: Date, default: addDate()},

    is_active: {type: Number, default: 1},
    statut: {type: Number, default: 0},
    reference: {type: String},
    user: {type: Schema.ObjectId, ref: 'user'}
});


/**
 * Validations
 */
// Fields to validate
// var errorCount = 0;
// var validate_fields = [
    // {'name': [
        // { 'max_length': 50 },
        // { 'require': true }
    // ]},
    // {'description': [
        // { 'max_length': 144 },
        // { 'require': true }
    // ]}
// ];
// validate_fields.forEach(function(field_datas) {
    // for (field in field_datas) {
        // field_datas[field].forEach(function(data) {
            // for (rule in data) {
                // if (rule === 'require') {
                    // TicketModelSchema.path(field).required(data[rule], field + ' cannot be blank');
                // }
                // else if (rule === 'max_length') {
                    // TODO
                // }
            // };
        // });
    // }
// });


/**
 * Inheritance
 */
TicketModelSchema.inherits = {
    creatAndSave: function() {
        console.log('Save');
        // auto generate keywords
        this.keywords = generateKeyWords(this.name);
        this.save();
    },
    // data = {name: String, description: String, actor_type: ObjectId}
    update: function(data) {
        for (property in data) {
            this[property] = data[property];
        }
        this.keywords = generateKeyWords(this.name);
        this.save();
    },
};


/**
 * Statics
 */
TicketModelSchema.statics = {
    // Find ticket by id
    // TODO: .populate('_user');
    // TODO: set a variable option to decide a load of json or not
    // TODO: id not found
    load: function(id, cb) {
        this.findOne({ _id: id }).exec(cb);
    },

    loadJson: function(id, cb) {
        this.find({ _id: id }).lean().exec(cb);
    },

    // List articles
    // TODO: pagination, populate(_user)
    list: function (options, cb) {
        var criteria = options.criteria || {};
        this.find(criteria).exec(cb);
    },

    // List to Json
    listToJson: function(options, cb) {
        var criteria = options.criteria || {};
        this.find(criteria).lean().exec(cb);
    },

    // find key in fields
    findObjectByKeyword: function(field, key, list, cb) {
        var target_list = list || [];
        var rule = {};
        rule[field] = new RegExp(key, 'i');

        if (target_list.length == 0) {
            this.find(rule)
                .distinct('_id')
                .exec(cb);
        }
        else {
            this.find(rule)
                .where('_id').in(target_list)
                .distinct('_id')
                .exec(cb);
        }
    },
    // Find tickets by classification_id
    findByClassification: function(classification_id, cb) {
        this.find()
            .where('classification').equals(classification_id)
            .exec(cb);
    },
    // Find tickets by author type id
    findByActorType: function(actor_id, cb) {
        this.find()
            .where('source_actor_type').equals(actor_id)
            .exec(cb);
    },
    // Find tickets by author type and classification (matching)
    findByActorTypeAndClassification: function(actor_id, classification_id, cb) {
        this.find()
            .where('classification').equals(classification_id)
            .where('source_actor_type').equals(actor_id)
            .exec(cb);
    },
    findIdByActorTypeAndClassification: function(actor_id, classification_id, cb) {
        this.find()
            .where('classification').equals(classification_id)
            .where('source_actor_type').equals(actor_id)
            .distinct('_id')
            .exec(cb);
    }
}

// TODO: Add this in lib/utils.js
function addDate() {
    var now = new Date()
    var dt = new Date(now.getFullYear(), now.getMonth() + 3, now.getDate());
    return dt;
}


// For the first step we generate keywords by name
// eliminating the worthless words in French language
// TODO: count occur times of keywords
function generateKeyWords(name) {
    var keywords = [];
    name = name.toLowerCase();
    var arr = name.split(' ');
    for (var index=0; index<arr.length; index++) {
        if (utils.worthlesswords.indexOf(arr[index]) < 0) {
            keywords.push(arr[index]);
        }
    }
    return keywords;
}


// Built and exports Model from Schema
mongoose.model('TicketModel', TicketModelSchema);
exports.TicketModel = mongoose.model('TicketModel');
// var TicketModel = exports.TicketModel = mongoose.model('TicketModel');

// Export Schema
exports.TicketModelSchema = TicketModelSchema;
